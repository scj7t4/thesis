\section{Modeling An Election Algorithm as a Stationarity Markov Chain}

%State how sequences are generated.
%State how transition probabilities are generated in the profile chain. State what the profile chain could be used for when collected.

% 3 sections
% Execution assumptions
% algorithmic changes
% producing the profile chain

\subsection{Execution Environment}

Execution occurs in a real-time synchronized environment.
Processes synchronize their clocks and execute steps of the election algorithm at predefined intervals.
Processes with clocks that are not sufficiently synchronized cannot form groups.
For this work, process execution occurs in an environment where the clocks are sufficiently synchronized to consistently form groups.

The execution environment is subject to omission failures.
In an omission failure, a message sent by one process to another process can be lost in transit.
Omission failures can occur for many reasons.
Network congestion is a typical culprit.
Routers may drop packets or delay their delivery when there is a large amount of traffic or a network issue.
In a real-time environment, packets that are delayed to miss real-time deadlines will have the same appearance as a dropped packet.
The execution environment for the election algorithm has a omission failure occurrence modeled as a Bernoulli trial.
In this model, each message has some probability $p$ of being delivered within the timing restraints imposed by the real-time schedule.

For the purpose of analyzing the affects of omission failures, processes are not subject to other faults.
A process will not crash or halt during execution.

\subsection{Election Algorithm}

The original Garcia-Molina algorithm has been modified so the observations of the coordinator process have the Markov property.
The full algorithm is presented below.
The rest of this section describes the changes that were made to the algorithm and shows how the combination of those changes allow the observations of the Coordinator to follow the Markov process.
The execution model of this algorithm assumes a real-time system using a round-robin scheduler.
At a predetermined time and following predetermined intervals the algorithm executes at each process.
Using the synchronized clocks, all processes execute either $Check()$ or $Timeout()$ at the same time.
Processes can only form groups if their clocks are sufficiently in sync with another process' clock.

\begin{algorithmic}

\State $AllNodes \gets \{ 1, 2, ..., N \}$
\State $Coordinators \gets \emptyset$
\State $UpNodes \gets { Me }$
\State $State \gets Normal$
\State $Coordinator \gets Me$
\State $Responses \gets \emptyset$
\State $Counter \gets$ A random initial identifier
\State $GroupID \gets (Me,Counter)$

\State

\Function{Check}{}
    \State This function is called at the start of a round by the leader
    \If {$State = Normal$ and $Coordinator \gets Me$}
        \State $Responses \gets \emptyset$
        \State $TempSet \gets \emptyset$
        \For {$j = (AllNodes - \{Me\})$}
            \State $AreYouCoordinator(j)$
            \State $TempSet \gets TempSet \cup j$
        \EndFor
        \State Nodes which respond "Yes" to $AreYouCoordinator$ are put into the $Responses$ set.
        \State When an $AreYouThere$ response is "No" and this process is a coordinator, the querying process is put in the $Responses$ set.
        \State Wait for $Timeout(CheckTimeout)$, Nodes that do not respond are removed from UpNodes.
        \State $UpNodes \gets (TempSet-Responses) \cup {Me}$
        \If {$Responses = \emptyset$}
            \Return
        \EndIf
        \State $p \gets \max(Responses)$
        \If $Me > p$
            \State Wait time proportional to me-p
        \EndIf
        \Call{Merge}{Responses}
    \EndIf
    \State The next call to this is after Timeout(CheckTimeout)
\EndFunction

\State

\Function{Timeout}{}
    \State This function is called at the start of a round by the group members
    \If {$Coordinator = Me$}
        \Return
    \Else
        \Call{AreYouThere}{Coordinator,GroupID,Me}
        \If{Response is No}
            \Call{Recovery}{}
        \EndIf
    \EndIf
    \State The next call to this is after Timeout(TimeoutTimeout)
\EndFunction

\State

\Function{Merge}{Coordinators}
    \State This function invites all coordinators in Coordinators to join a group led by Me
    \State $State \gets Election$
    \State Stop work
    \State $Counter \gets Counter+1$
    \State $GroupID \gets (Me,Counter)$
    \State $Coordinator \gets Me$
    \State $TempSet \gets UpNodes - {Me}$
    \State $UpNodes \gets \emptyset$
    \For {$j \in Coordinators$}
        \Call{Invite}{j,Coordinator,GroupID}
    \EndFor
    \For {$j \in TempSet$}
        \Call{Invite}{j,Coordinator,GroupID}
    \EndFor
    \State Wait for $Timeout(InviteTimeout)$, Nodes that accept the invite are added to UpNodes
    \State $State \gets Reorganization$
    \For {$j \in UpNodes$}
        \Call{Ready}{j,Coordinator,GroupID,UpNodes}
    \EndFor
    \State $Acknowledge \gets UpNodes$
    \State Wait for $Timeout(ReadyTimeout)$, Nodes that do not acknowledge are removed from UpNodes
    \State $UpNodes \gets UpNodes - Acknowledge$
    \State $State \gets Normal$
\EndFunction

\State

\Function{ReceiveReady}{Sender,Leader, Identifier, Peers}
    \If {$State = Reorganization$ and $GroupID = Identifier$}
        \State $UpNodes \gets Peers$
        \State $State \gets Normal$
        \State Respond Ready Acknowledge 
    \EndIf
\EndFunction

\State

\Function{ReceiveAreYouCoordinator}{Sender}
    \If {$State = Normal$ and $Coordinator = Me$}
        \State Respond Yes
    \Else
        \State Respond No
    \EndIf
\EndFunction

\State

\Function{ReceiveAreYouThere}{Sender, Identifier}
    \If {$GroupID = Identifier$ and $Coordinator = Me$ and $Sender \in UpNodes$}
        \State Respond Yes
    \Else
        \State Respond No
        \State Add sender to $Responses$ set for $Check()$ if this process is a coordinator.
    \EndIf
\EndFunction

\State

\Function{ReceiveInvitation}{Sender,Leader,Identifier}
    \If {$State \neq Normal$}
        \Return
    \EndIf
    \If {$Sender \neq 0$}
        \Return
    \EndIf
    \State Stop Work
    \State $Temp \gets Coordinator$
    \State $TempSet \gets UpNodes$
    \State $State \gets Election$
    \State $Coordinator \gets Leader$
    \State $GroupID \gets Identifier$
    \If {$Temp = Me$}
        \State Forward invite to old group members
        \For $j \in TempSet$
            \State $Invite(j,Coordinator,GroupID)$
        \EndFor
    \EndIf
    \State $Accept(Coordinator,GroupID)$
    \State $State \gets Reorganization$
    \If {$Timeout(ReadyTimeout)$ expires before $Ready$ is received}
        \State $Recovery()$
    \EndIf
\EndFunction

\State

\Function{ReceiveAccept}{Sender,Leader,Identifier}
    \If {$State \gets Election$ and $GroupID = Identifier$ and $Coordinator = Leader$}
        \State $UpNodes \gets UpNodes \cup {Sender}$
    \EndIf
\EndFunction

\Function{ReceiveReadyAcknowledge}{Sender}
    \State $Sender$ is removed from $Acknowledge$ in $Merge()$
\EndFunction

\State

\Function{Recovery}{}
    \State $State \gets Election$
    \State Stop Work
    \State $Counter \gets Counter + 1$
    \State $GroupID \gets (Me,Counter)$
    \State $Coordinator \gets Me$
    \State $UpNodes \gets {Me}$
    \State $State \gets Reorganization$
    \State $State \gets Normal$
\EndFunction

\end{algorithmic}

In a distributed system information cannot be instantaneously spread throughout the system.
A process can only make local observations.
In this work, we attempt to model what a process will observe as a result of omission failure.
Therefore, it is important that observations that a process makes hold to the Markov property.
In the original algorithm, there are several portions that, when projected to the leader's observation, do not meet the Markov property.
The following sections state the portions of the algorithm where the observation of the leader process does not yield the probability of next transition.

Leader selection is performed a priori-- only process 0 may become the leader of a multiprocess group.
This simplification was applied because the configuration of the system with a larger number of processes depended on the configuration of the other processes.
Without this simplification, the state of the rest of the system would not have the memoryless property.
The state of the processes that are not in the observers group would change each round.
As a consequence the state of the rest of the system and the likelihood of forming a specific group size would change each step if other processes could become leader.

DIAGRAM HERE

The changes added a third message to completing an election -- a ready acknowledge message.
This message is sent by a member after receiving the ready message from the coordinator.
This allows the coordinator to be certain of the member's status before the next round.
Without the ready acknowledgment, the member may not receive the ready message and the coordinator will observe the member is a part of the group.
As a consequence of that uncertainty, the probability that a member remains in a group in the first round after an election has a different probability than each subsequent round.
By adding the extra message, the observation of the coordinator of the state, must be the state of the member of the group.
The sequence presented in figure XXX is not possible and as a consequence, the probability a member remains in a group in the first round after an election is a fixed value.

DIAGRAM HERE

Members cannot leave a group without the leader's permission.
Members do not suspect the coordinator has failed, only the coordinator may suspect the members.
For the purpose of starting an election, an Are You There message and it's negative response are considered equivalent to a Are You Coordinator message and a positive response.
On receipt of the negative response, the member will immediately recover and become a leader.
This assumption relies on Are You Coordinator and Are You There messages being sent at roughly the same time.

DIAGRAM HERE

This change leads to a live-lock situation in a crash failure, where the group's leader crashes and does not return and as a consequence the remaining members are trapped in a group without a leader.
For the purpose of this work, we have disregarded these live lock scenarios.
However, the live-lock could be avoided if the member can detect that it has not received an "Are You Coordinator" message in a round.
When the process fails to receive the message, the coordinator must have also removed the member from their group since they could not have received a "Are You Coordinator" response message.
Integrating this component is an area of future work.

\subsection{Creation of A Profile Chain}

The profile Markov chain for the algorithm was constructed as a closed form representation of the algorithms behavior.
The chain models the observations of a single process.
The process can only observe what it considers it's local group.
In a distributed system, information about what other processes consider to be their state cannot be easily known.
Therefore, a model should only consider the effects a process could locally observe.

Each round, the behavior is described by two components: maintaining a group that already exists, and inviting other processes into the group.
The coordinator will exchange a ''Are You Coordinator'' message and the peer will respond to verify is still available.
To maintain a group of $m$ other processes, the probability is defined as a random variable with the following probability distribution (pdf):

\[
 \Pr_{M}(X=k; m) = 
 
   \begin{cases}
    \binom{m}{k} p^{2k}(1-p^2)^{m-k} & \quad \text{if } 0 \leq k \leq m \\
    0                                & \quad \text{otherwise} \\
  \end{cases}
\]

Where $k$ is the number of processes that remain in a group selected from $n$ processes.
A process will leave a group if, from the consider process' perspective, they do not respond to an ''Are You Coordinator'' message.
A process cannot leave a group without the coordinator's permission: other processes cannot change their state without coordinating with the leader.

To invite other processes to the group, the two processes ultimately exchange up to 8 messages.
In a round, a single process can invite many other processes to its group.
From a selection of $n$ other coordinators, the probability distribution for joining a new group with $k$ of the $n$ processes is:

\[
	\Pr_{I}(Y=k; n) =
	\begin{cases}
		\binom{n}{k} p^{8k}(1-p^8)^{n-k} & \quad \text{if } 0 \leq k \leq n
		0                                & \quad \text{otherwise}
	\end{cases}
\]

In the profile chain, in a state $s$ which describes the number of processes in a group, the probability of transitioning from $s$ to $s'$ with $n$ total processes (including the considered process) is:

\[ \Pr_{T}(Z=s'; n; s) = \sum_{i=0}^{s-1} \sum_{j=0}^{s'-i-1} \Pr_{M}(X=i; s-1) \Pr_{I}(X=j; n-s-1) \]

From this distribution, a set of transition probabilities can be calculated for a given omission rate $p$ and number of processes $n$.
This set of transition probabilities forms a profile Markov chain $P$, which can be evaluated to for any number of processes $n$ and omission rate $p$.
The generated profile chain is ergodic when $0<p<1.0$.


