\chapter{Related Work}

\section{Virtual Synchrony}

Consider a distributed system where events can be causually related based
on their execution on the local processors and communication between
processes, as defined in CITE. Virtually synchronous systems use multicast
to communicate reliabily between proceses.

\begin{enumerate}
    \item If $e$ and $e'$ are events local to a process $P_{i}$ and $e$ occurs before $e'$, then $e \rightarrow e'$
    \item If $e = send(m) and e'=deliver(m)$ for the same message $m$, then $e \rightarrow e'$
\end{enumerate}

This defines a dependence and casuality relation between events in the system.
If two events cannot be causually related (that is $e \not\rightarrow e'$ and
$e' \not\rightarrow e$ then the events are considered concurrent. From this
one can define an execution history $H$.

Virtual synchrony is a concept employed by a great number of distributed
frameworks to impose synchronization on a system. Virtual synchrony is a
model of communication and execution that allows the system designer to
enforce synchronization on the system. Although the processes do not
execute tasks simultaneously, the execution history of each process cannot
be differenitated from a trace where tasks are executed simultaneously. A
pair of histories $H$ and $H'$ are equivalent if for each procress in the
system (noted as $p$) $H|_{p}$ cannot be differenatiated $H'|_{p}$ based
on the casual relationships between the events in the history.

Additionally, a history is considered complete if all sent messages are
delivered and there are no casual holes. A casual hole is a circumstance
where an event $e$ is casually related to $e'$ by $e' \rightarrow e$ and
$e$ appears in a history, but $e'$ is not. 

A virtually synchronous system is one where each history the system is
indistinguishable from all histories produced by a synchronous system.

\subsection{Process Groups}

Virtual synchrony models also support process groups. Although each
implementation of a virtually synchron/ous system applies a different structure
to the way processes are grouped, there are common features between each
implementation.

A process group in a virtual synchronous system is commonly refered to as a
view. A view is a collection of processes that are virtually synchronous
with eachother. Process groups in virtually synchronous systems place 
obligations on the delivery of messages to members of the view. A history
$H$ is legal if:

\begin{enumerate}
    \item Given a function $time(e)$ that returns a global time of when the event occured $e$, then $e \rightarrow e' \Rightarrow time(e) < time(e').$
    \item $time(e) \neq time(e') \forall e, e' \in H|_{p}$ (where $e \neq e'$) for each process.
    \item A change in view (group membership) occur at the same logical time for all processes in the view.
    \item All multicast message deliveres occur in the view of a group. That is, if a message is sent in a view, it is delivered in that view, for every process in that view.
    \item Atomic broadcast ($abcast$) messages are totally ordered.
\end{enumerate}

A process group interacting creates a legal history for the virtually
synchronous system. However, processes can fail. The crash-failure model is
commonly used. To achieve this, the virtual synchrony model has the following
properties:

\begin{itemize}
    \item The system employs a membership service. This service monitors for failures and reports them to the other processes as part of the process group (or view) system.
    \item When a process is identified as failing it is removed from the groups that it belongs to and the remainin processes determine a new view.
    \item After a process has been identified as failing, no message will be recieved from it.
\end{itemize}

As part of the failure model, it is worth noting two commonly used multicast
delivery garuntees: uniform and non-uniform. The uniform propery obligates that
if one multicast is delivered to a node in the current view, it is delivered to
all nodes in the current view.

\subsection{Comparison To DGI}

The DGI places similar but distinct requirements on execution of processes in
its system. The DGI enforces synchronization between processes that obligates
each active process to enter each module's phase simultaneously. This is
fulfilled by using a clock synchronization algorithm. The virtual synchrony
model, at its most basic, does not require a clock to enforce its ordering.

However, this simplifies the DGI fulfilling it's real time requirements. 
processes must be able to react to changes in the power system within a
maximum amount of time. These interactions do not require interaction between
all processes within the group. Additionally, this allows for private
transactions to occur between DGI processes.

The DGI has also been implemented using message delivery schemes that are
unicast instead of multicast, since this is the easiest to achieve. A
majority of systems implementing virtual synchrony use a model where local
area communication is emphasized, with additional structures in place to
transfer information across a WAN to other process groups.

\section{Isis and Horus}

A product of Dr. Kenneth Birman and his group at Cornell, Isis and Horus are
two distributed frameworks which are comparable to the DGI. Although these
projects are no longer actively developed, it is worth understanding them,
to better grasp their successor, Spread, which will be compared to DGI later
in this work.

Isis was originally developed to create a reliable distributed framework for
creating other applications. As Isis was one of the first of its kind, the
burden of maintaining a robust framework that met the development needs of its
users eventually made Birman's group create a newer, updated framework called
Horus. However, Isis and Horus largely implement the same concepts.

Horus/Isis are described as a group communications system. They provide a 
messaging architecture which clients use to deliver messages between processes.
The frameworks provide a reliabile distributed multicast, and a failure
detection scheme.

\subsection{Group Model}
In Horus and Isis, a group is a collection of processes which can communicate with one
another to do work. Multicasts are directed to the group, and are gaurnteed to
be recieved by all members or no members. The collection of processes which
make up a group is called a view.

Over time, due to failure, the view will change. Since views are distributed
concurrently and asynchronously, each process can have a different view. Horus
is designed to have a modular communication structure, which allows the 
communication channel to have different properties which will affect which 
messages will be delivered in the event of a view change.

Both Horus and Isis have limited support for partitioning. In the event that
a partition forms, dividing the large group into subgroups, only the primary
group is allowed to continue operating. The primary group is selected by
choosing the largest partition. By their own description, only the primary
group is allowed to continue working. This is to allow the partitions to
reffififijoin: only the work from the primary partition should be used.

\section{Totem}

Totem is largely in the same vein as Isis. Developed at the University of
California, Santa Barbara by Moser, Melliar-Smith, Agarwal et. al. Totem is
designed to use local area networks, connected by gateways. The local area
networks use a token passing ring and multicast the messages, much like Isis
and Horus. The gateways join these rings into a multi-ring topology.

Like Isis, the message protocol gives the message total ordering using a
token passing protocol.

\section{Spread}

